what is NgRx?
- It is an angular specific state management solution, that allow us to create the client side database with our data
- It allow us to minimize number of http request to server
- It allow us to easily render new version of data in different parts of our view
- Imporves user experience with minimal loading indicator

Install NgRx
- ng add @ngrx/store
- It updates app.module.ts import section with "StoreModule.forRoot(reducers, {metaReducers})"

- ng add @ngrx/store-devtools  - It is a browser extension tool that allow us to see the content of our in-memory database in chrome dev tools
- It updates app.module.ts import section with "StoreDevtoolsModule.instrument({maxAge: 25, logOnly: environment.production})"
- Install redux dev tool extension in chrome


- ngRx Schematic commands
  - ng generate store auth/Auth --module auth.module.ts   => this add some store configuration to auth.module.ts



- Store Service API - It allow us to communicate with in-memory database

- Action(NgRx key):  Action is a plain javascript object which we send to "Store" in order to trigger modification.
   - Its more often an event reporting something happened at component level
   - Action always has a type and payload but not manadatory.
   - dispatching of action is the only way to modifiy the stored state 

        eg: this.store.dispatch({
            type: "Login Action",
            payload: { 
                user //*** or user: user
            }  
        })

        better way to write action is to create separate action file (eg: auth.action.ts)
        
        export const login = createAction(
            "[Login Page] User Login", //*** [Login Page] is source of action from where it is triggered  and second part "User Login" is event which occured with this action.
            props<{user: User}>()  //*** props is function from "Store" which do not take any argument but only payload
            );

        so above eg: modifies to 
        thos.store.dispatch(login({user})) /**** {user} is payload ***/


 - Reducer(NgRx key): It is plain javascript function it will take current state of store, action and return the new state of Store in response to action.
    eg: 
    function authReducer(state, action): Store{}

    export interface AuthState {

    }
    export const reducers: ActionReducer<AuthState> = {
        
    };

    // rewriting in Ngrx way "function authReducer(state, action): Store{}"

    export const authReducer = createReducer({
        initialAuthState,
        on(AuthAction.login, (state,action)=>{
            return {
                user: action.user
            }
        })
    })
       
 Optimising Plain mapping function with Store provided selector mapping function

 Since the Observable get trigger whenever a new action dispatch to store.. this.isLoggedIn$ gets triggered which is not required.. It should only 
 be triggered when the value of "user has been changed"

 old implementation
     this.isLoggedIn$ = this.store.pipe(
        map((store)=> !!store["auth"].user)
      )

 Optimized implementation
    need to create selector for auth (auth.selector.ts) 
    // We can pass multiple arguments related to store state, minimum two arguments are required, last agrument is projector function which returns the consolidated data
    // Its a mapping funciton or Memoized function created using createSelector has memory as long as input state of "auth" not changed the output wil not be calculated
        export const isLoggedIn = createSelector(
            (store)=> store["auth"],
            (auth) => !!auth.user
        )


     this.isLoggedIn$ = this.store.pipe(select(isLoggedIn))


  Writing a typed safed version of this implementation using createFeatureSelector. It only take one argument which is the name of the property we want to access from root Store

   current version: 
        export const isLoggedIn = createSelector(
            (store)=> store["auth"],
            (auth) => !!auth.user
        )   


  Updated version: 
        export const selectAuthState = createFeatureSelector<AuthState>("auth")
         export const isLoggedIn = createSelector(
            selectAuthState,
            (auth) => !!auth.user
        )


  NgRx Effect - In order to presist the store data we can user "Effects" to store in the third party storage (localstorage or on backend server)
                whenever user refresh browser we can fetch data from third party storage and update store data

                implementation: 
                import EffectsModule.forRoot([]) in root module with .forRoot
                import EffectsModule.forFeature([]) in auth module(feature module) with .forFeature

         Side Effect in NgRx is something extra we have to done after an action is triggered which result in store state change or reducer excecution we want store some data to 3rd party storage..

         eg: In genric implementation we have create a AuthEffect service which will be registered in EffectsModule.forFeature([AuthEffects]). With the help of of NgRx api "Action" we will be able 
             to capture action type and store data to 3rd party storage.

             Gneric implementation has some drawback as its not typesafe and no error handing is there if something went wrong. To overcome this we will consume NgRx inbuilt API. 
         @Injectable()
            export class AuthEffects {
                constructor(private actions$: Actions){
                    this.actions$.subscribe((action)=>{
                        if(action.type === '[Login Page] User Login'){
                            localStorage.setItem('user',JSON.stringify(action["user"]))
                        }
                    })
                }
            }       


            Optimized implementation using NgRx createEffect

            login$ = createEffect(()=>
                    this.actions$.pipe(
                        ofType(AuthActions.login),
                        tap((action)=>{
                            localStorage.setItem('user', JSON.stringify(action.user))
                        })
                    )
            ,{dispatch: false})

